diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/CMakeLists.txt particlefilter/CMakeLists.txt
--- ../original_src/rodinia_3.1/openmp/particlefilter/CMakeLists.txt	1969-12-31 16:00:00.000000000 -0800
+++ particlefilter/CMakeLists.txt	2021-07-27 20:39:59.650975000 -0700
@@ -0,0 +1,31 @@
+
+include_directories(
+    ${CMAKE_CURRENT_BINARY_DIR}
+)
+
+SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -march=native -fopenmp")
+SET(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -O3 -march=native -fopenmp")
+set(SRC_FILES "particlefilter.cpp")
+set(APP_NAME "pFilter")
+
+execute_process(COMMAND python ${CMAKE_SOURCE_DIR}/configure.py 
+    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR} 
+    ${CMAKE_CURRENT_SOURCE_DIR} ${APP_NAME} ${SRC_FILES}
+    OUTPUT_VARIABLE CREATED_FILES)
+
+string(REPLACE " " ";" CREATED_FILES ${CREATED_FILES})
+add_compile_options("-fapprox")
+foreach(DIR_NAME ${CREATED_FILES})
+    string(STRIP ${DIR_NAME} DIR_NAME)
+    set(TMP_SRC "")
+    set(EXE_NAME "${APP_NAME}_${DIR_NAME}.exe")
+    foreach (sf ${SRC_FILES})
+        list(APPEND TMP_SRC "${CMAKE_CURRENT_BINARY_DIR}/${DIR_NAME}/${sf}")
+    endforeach()
+    add_executable(${EXE_NAME} ${TMP_SRC})
+    target_link_libraries(${EXE_NAME} ${LIBAPPROX_LIB_FILE})
+    target_include_directories(${EXE_NAME} PUBLIC ${APPROX_LIB_UTIL_DIR}/)
+    set_target_properties(${EXE_NAME} PROPERTIES LINK_FLAGS "-lapprox")
+endforeach()
+
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/Makefile particlefilter/Makefile
--- ../original_src/rodinia_3.1/openmp/particlefilter/Makefile	2021-07-27 19:40:03.130236000 -0700
+++ particlefilter/Makefile	1969-12-31 16:00:00.000000000 -0800
@@ -1,12 +0,0 @@
-#makefile
-
-openmp: ex_particle_OPENMP_seq.c
-	gcc -O3 -ffast-math -fopenmp ex_particle_OPENMP_seq.c -o particle_filter -lm 
-
-
-icc_openmp: ex_particle_OPENMP_seq.c
-	icc -O3 -fast -openmp ex_particle_OPENMP_seq.c -o particle_filter
-
-
-clean:
-	rm particle_filter
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/benchDescr.yaml particlefilter/benchDescr.yaml
--- ../original_src/rodinia_3.1/openmp/particlefilter/benchDescr.yaml	1969-12-31 16:00:00.000000000 -0800
+++ particlefilter/benchDescr.yaml	2021-07-27 20:39:59.669963000 -0700
@@ -0,0 +1,6 @@
+pFilter:
+    input: ["128_128_20_1000"]
+    cmd: '-x 128 -y 128 -z 20 -np 10000 -out <output>'
+    measure: 'RUN_TIME:(\d+\.\d+)'
+    metric: 'MAE'
+    quality_pattern: 'OUTPUT_QUALITY:([0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)'
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/ex_particle_OPENMP_seq.c particlefilter/ex_particle_OPENMP_seq.c
--- ../original_src/rodinia_3.1/openmp/particlefilter/ex_particle_OPENMP_seq.c	2021-07-27 19:40:03.108259000 -0700
+++ particlefilter/ex_particle_OPENMP_seq.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,601 +0,0 @@
-/**
- * @file ex_particle_OPENMP_seq.c
- * @author Michael Trotter & Matt Goodrum
- * @brief Particle filter implementation in C/OpenMP 
- */
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <sys/time.h>
-#include <omp.h>
-#include <limits.h>
-#define PI 3.1415926535897932
-/**
-@var M value for Linear Congruential Generator (LCG); use GCC's value
-*/
-long M = INT_MAX;
-/**
-@var A value for LCG
-*/
-int A = 1103515245;
-/**
-@var C value for LCG
-*/
-int C = 12345;
-/*****************************
-*GET_TIME
-*returns a long int representing the time
-*****************************/
-long long get_time() {
-	struct timeval tv;
-	gettimeofday(&tv, NULL);
-	return (tv.tv_sec * 1000000) + tv.tv_usec;
-}
-// Returns the number of seconds elapsed between the two specified times
-float elapsed_time(long long start_time, long long end_time) {
-        return (float) (end_time - start_time) / (1000 * 1000);
-}
-/** 
-* Takes in a double and returns an integer that approximates to that double
-* @return if the mantissa < .5 => return value < input value; else return value > input value
-*/
-double roundDouble(double value){
-	int newValue = (int)(value);
-	if(value - newValue < .5)
-	return newValue;
-	else
-	return newValue++;
-}
-/**
-* Set values of the 3D array to a newValue if that value is equal to the testValue
-* @param testValue The value to be replaced
-* @param newValue The value to replace testValue with
-* @param array3D The image vector
-* @param dimX The x dimension of the frame
-* @param dimY The y dimension of the frame
-* @param dimZ The number of frames
-*/
-void setIf(int testValue, int newValue, int * array3D, int * dimX, int * dimY, int * dimZ){
-	int x, y, z;
-	for(x = 0; x < *dimX; x++){
-		for(y = 0; y < *dimY; y++){
-			for(z = 0; z < *dimZ; z++){
-				if(array3D[x * *dimY * *dimZ+y * *dimZ + z] == testValue)
-				array3D[x * *dimY * *dimZ + y * *dimZ + z] = newValue;
-			}
-		}
-	}
-}
-/**
-* Generates a uniformly distributed random number using the provided seed and GCC's settings for the Linear Congruential Generator (LCG)
-* @see http://en.wikipedia.org/wiki/Linear_congruential_generator
-* @note This function is thread-safe
-* @param seed The seed array
-* @param index The specific index of the seed to be advanced
-* @return a uniformly distributed number [0, 1)
-*/
-double randu(int * seed, int index)
-{
-	int num = A*seed[index] + C;
-	seed[index] = num % M;
-	return fabs(seed[index]/((double) M));
-}
-/**
-* Generates a normally distributed random number using the Box-Muller transformation
-* @note This function is thread-safe
-* @param seed The seed array
-* @param index The specific index of the seed to be advanced
-* @return a double representing random number generated using the Box-Muller algorithm
-* @see http://en.wikipedia.org/wiki/Normal_distribution, section computing value for normal random distribution
-*/
-double randn(int * seed, int index){
-	/*Box-Muller algorithm*/
-	double u = randu(seed, index);
-	double v = randu(seed, index);
-	double cosine = cos(2*PI*v);
-	double rt = -2*log(u);
-	return sqrt(rt)*cosine;
-}
-/**
-* Sets values of 3D matrix using randomly generated numbers from a normal distribution
-* @param array3D The video to be modified
-* @param dimX The x dimension of the frame
-* @param dimY The y dimension of the frame
-* @param dimZ The number of frames
-* @param seed The seed array
-*/
-void addNoise(int * array3D, int * dimX, int * dimY, int * dimZ, int * seed){
-	int x, y, z;
-	for(x = 0; x < *dimX; x++){
-		for(y = 0; y < *dimY; y++){
-			for(z = 0; z < *dimZ; z++){
-				array3D[x * *dimY * *dimZ + y * *dimZ + z] = array3D[x * *dimY * *dimZ + y * *dimZ + z] + (int)(5*randn(seed, 0));
-			}
-		}
-	}
-}
-/**
-* Fills a radius x radius matrix representing the disk
-* @param disk The pointer to the disk to be made
-* @param radius  The radius of the disk to be made
-*/
-void strelDisk(int * disk, int radius)
-{
-	int diameter = radius*2 - 1;
-	int x, y;
-	for(x = 0; x < diameter; x++){
-		for(y = 0; y < diameter; y++){
-			double distance = sqrt(pow((double)(x-radius+1),2) + pow((double)(y-radius+1),2));
-			if(distance < radius)
-			disk[x*diameter + y] = 1;
-		}
-	}
-}
-/**
-* Dilates the provided video
-* @param matrix The video to be dilated
-* @param posX The x location of the pixel to be dilated
-* @param posY The y location of the pixel to be dilated
-* @param poxZ The z location of the pixel to be dilated
-* @param dimX The x dimension of the frame
-* @param dimY The y dimension of the frame
-* @param dimZ The number of frames
-* @param error The error radius
-*/
-void dilate_matrix(int * matrix, int posX, int posY, int posZ, int dimX, int dimY, int dimZ, int error)
-{
-	int startX = posX - error;
-	while(startX < 0)
-	startX++;
-	int startY = posY - error;
-	while(startY < 0)
-	startY++;
-	int endX = posX + error;
-	while(endX > dimX)
-	endX--;
-	int endY = posY + error;
-	while(endY > dimY)
-	endY--;
-	int x,y;
-	for(x = startX; x < endX; x++){
-		for(y = startY; y < endY; y++){
-			double distance = sqrt( pow((double)(x-posX),2) + pow((double)(y-posY),2) );
-			if(distance < error)
-			matrix[x*dimY*dimZ + y*dimZ + posZ] = 1;
-		}
-	}
-}
-
-/**
-* Dilates the target matrix using the radius as a guide
-* @param matrix The reference matrix
-* @param dimX The x dimension of the video
-* @param dimY The y dimension of the video
-* @param dimZ The z dimension of the video
-* @param error The error radius to be dilated
-* @param newMatrix The target matrix
-*/
-void imdilate_disk(int * matrix, int dimX, int dimY, int dimZ, int error, int * newMatrix)
-{
-	int x, y, z;
-	for(z = 0; z < dimZ; z++){
-		for(x = 0; x < dimX; x++){
-			for(y = 0; y < dimY; y++){
-				if(matrix[x*dimY*dimZ + y*dimZ + z] == 1){
-					dilate_matrix(newMatrix, x, y, z, dimX, dimY, dimZ, error);
-				}
-			}
-		}
-	}
-}
-/**
-* Fills a 2D array describing the offsets of the disk object
-* @param se The disk object
-* @param numOnes The number of ones in the disk
-* @param neighbors The array that will contain the offsets
-* @param radius The radius used for dilation
-*/
-void getneighbors(int * se, int numOnes, double * neighbors, int radius){
-	int x, y;
-	int neighY = 0;
-	int center = radius - 1;
-	int diameter = radius*2 -1;
-	for(x = 0; x < diameter; x++){
-		for(y = 0; y < diameter; y++){
-			if(se[x*diameter + y]){
-				neighbors[neighY*2] = (int)(y - center);
-				neighbors[neighY*2 + 1] = (int)(x - center);
-				neighY++;
-			}
-		}
-	}
-}
-/**
-* The synthetic video sequence we will work with here is composed of a
-* single moving object, circular in shape (fixed radius)
-* The motion here is a linear motion
-* the foreground intensity and the backgrounf intensity is known
-* the image is corrupted with zero mean Gaussian noise
-* @param I The video itself
-* @param IszX The x dimension of the video
-* @param IszY The y dimension of the video
-* @param Nfr The number of frames of the video
-* @param seed The seed array used for number generation
-*/
-void videoSequence(int * I, int IszX, int IszY, int Nfr, int * seed){
-	int k;
-	int max_size = IszX*IszY*Nfr;
-	/*get object centers*/
-	int x0 = (int)roundDouble(IszY/2.0);
-	int y0 = (int)roundDouble(IszX/2.0);
-	I[x0 *IszY *Nfr + y0 * Nfr  + 0] = 1;
-	
-	/*move point*/
-	int xk, yk, pos;
-	for(k = 1; k < Nfr; k++){
-		xk = abs(x0 + (k-1));
-		yk = abs(y0 - 2*(k-1));
-		pos = yk * IszY * Nfr + xk *Nfr + k;
-		if(pos >= max_size)
-		pos = 0;
-		I[pos] = 1;
-	}
-	
-	/*dilate matrix*/
-	int * newMatrix = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);
-	imdilate_disk(I, IszX, IszY, Nfr, 5, newMatrix);
-	int x, y;
-	for(x = 0; x < IszX; x++){
-		for(y = 0; y < IszY; y++){
-			for(k = 0; k < Nfr; k++){
-				I[x*IszY*Nfr + y*Nfr + k] = newMatrix[x*IszY*Nfr + y*Nfr + k];
-			}
-		}
-	}
-	free(newMatrix);
-	
-	/*define background, add noise*/
-	setIf(0, 100, I, &IszX, &IszY, &Nfr);
-	setIf(1, 228, I, &IszX, &IszY, &Nfr);
-	/*add noise*/
-	addNoise(I, &IszX, &IszY, &Nfr, seed);
-}
-/**
-* Determines the likelihood sum based on the formula: SUM( (IK[IND] - 100)^2 - (IK[IND] - 228)^2)/ 100
-* @param I The 3D matrix
-* @param ind The current ind array
-* @param numOnes The length of ind array
-* @return A double representing the sum
-*/
-double calcLikelihoodSum(int * I, int * ind, int numOnes){
-	double likelihoodSum = 0.0;
-	int y;
-	for(y = 0; y < numOnes; y++)
-	likelihoodSum += (pow((I[ind[y]] - 100),2) - pow((I[ind[y]]-228),2))/50.0;
-	return likelihoodSum;
-}
-/**
-* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index
-* @note This function uses sequential search
-* @param CDF The CDF
-* @param lengthCDF The length of CDF
-* @param value The value to be found
-* @return The index of value in the CDF; if value is never found, returns the last index
-*/
-int findIndex(double * CDF, int lengthCDF, double value){
-	int index = -1;
-	int x;
-	for(x = 0; x < lengthCDF; x++){
-		if(CDF[x] >= value){
-			index = x;
-			break;
-		}
-	}
-	if(index == -1){
-		return lengthCDF-1;
-	}
-	return index;
-}
-/**
-* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index
-* @note This function uses binary search before switching to sequential search
-* @param CDF The CDF
-* @param beginIndex The index to start searching from
-* @param endIndex The index to stop searching
-* @param value The value to find
-* @return The index of value in the CDF; if value is never found, returns the last index
-* @warning Use at your own risk; not fully tested
-*/
-int findIndexBin(double * CDF, int beginIndex, int endIndex, double value){
-	if(endIndex < beginIndex)
-	return -1;
-	int middleIndex = beginIndex + ((endIndex - beginIndex)/2);
-	/*check the value*/
-	if(CDF[middleIndex] >= value)
-	{
-		/*check that it's good*/
-		if(middleIndex == 0)
-		return middleIndex;
-		else if(CDF[middleIndex-1] < value)
-		return middleIndex;
-		else if(CDF[middleIndex-1] == value)
-		{
-			while(middleIndex > 0 && CDF[middleIndex-1] == value)
-			middleIndex--;
-			return middleIndex;
-		}
-	}
-	if(CDF[middleIndex] > value)
-	return findIndexBin(CDF, beginIndex, middleIndex+1, value);
-	return findIndexBin(CDF, middleIndex-1, endIndex, value);
-}
-/**
-* The implementation of the particle filter using OpenMP for many frames
-* @see http://openmp.org/wp/
-* @note This function is designed to work with a video of several frames. In addition, it references a provided MATLAB function which takes the video, the objxy matrix and the x and y arrays as arguments and returns the likelihoods
-* @param I The video to be run
-* @param IszX The x dimension of the video
-* @param IszY The y dimension of the video
-* @param Nfr The number of frames
-* @param seed The seed array used for random number generation
-* @param Nparticles The number of particles to be used
-*/
-void particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){
-	
-	int max_size = IszX*IszY*Nfr;
-	long long start = get_time();
-	//original particle centroid
-	double xe = roundDouble(IszY/2.0);
-	double ye = roundDouble(IszX/2.0);
-	
-	//expected object locations, compared to center
-	int radius = 5;
-	int diameter = radius*2 - 1;
-	int * disk = (int *)malloc(diameter*diameter*sizeof(int));
-	strelDisk(disk, radius);
-	int countOnes = 0;
-	int x, y;
-	for(x = 0; x < diameter; x++){
-		for(y = 0; y < diameter; y++){
-			if(disk[x*diameter + y] == 1)
-				countOnes++;
-		}
-	}
-	double * objxy = (double *)malloc(countOnes*2*sizeof(double));
-	getneighbors(disk, countOnes, objxy, radius);
-	
-	long long get_neighbors = get_time();
-	printf("TIME TO GET NEIGHBORS TOOK: %f\n", elapsed_time(start, get_neighbors));
-	//initial weights are all equal (1/Nparticles)
-	double * weights = (double *)malloc(sizeof(double)*Nparticles);
-	#pragma omp parallel for shared(weights, Nparticles) private(x)
-	for(x = 0; x < Nparticles; x++){
-		weights[x] = 1/((double)(Nparticles));
-	}
-	long long get_weights = get_time();
-	printf("TIME TO GET WEIGHTSTOOK: %f\n", elapsed_time(get_neighbors, get_weights));
-	//initial likelihood to 0.0
-	double * likelihood = (double *)malloc(sizeof(double)*Nparticles);
-	double * arrayX = (double *)malloc(sizeof(double)*Nparticles);
-	double * arrayY = (double *)malloc(sizeof(double)*Nparticles);
-	double * xj = (double *)malloc(sizeof(double)*Nparticles);
-	double * yj = (double *)malloc(sizeof(double)*Nparticles);
-	double * CDF = (double *)malloc(sizeof(double)*Nparticles);
-	double * u = (double *)malloc(sizeof(double)*Nparticles);
-	int * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles);
-	#pragma omp parallel for shared(arrayX, arrayY, xe, ye) private(x)
-	for(x = 0; x < Nparticles; x++){
-		arrayX[x] = xe;
-		arrayY[x] = ye;
-	}
-	int k;
-	
-	printf("TIME TO SET ARRAYS TOOK: %f\n", elapsed_time(get_weights, get_time()));
-	int indX, indY;
-	for(k = 1; k < Nfr; k++){
-		long long set_arrays = get_time();
-		//apply motion model
-		//draws sample from motion model (random walk). The only prior information
-		//is that the object moves 2x as fast as in the y direction
-		#pragma omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)
-		for(x = 0; x < Nparticles; x++){
-			arrayX[x] += 1 + 5*randn(seed, x);
-			arrayY[x] += -2 + 2*randn(seed, x);
-		}
-		long long error = get_time();
-		printf("TIME TO SET ERROR TOOK: %f\n", elapsed_time(set_arrays, error));
-		//particle filter likelihood
-		#pragma omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)
-		for(x = 0; x < Nparticles; x++){
-			//compute the likelihood: remember our assumption is that you know
-			// foreground and the background image intensity distribution.
-			// Notice that we consider here a likelihood ratio, instead of
-			// p(z|x). It is possible in this case. why? a hometask for you.		
-			//calc ind
-			for(y = 0; y < countOnes; y++){
-				indX = roundDouble(arrayX[x]) + objxy[y*2 + 1];
-				indY = roundDouble(arrayY[x]) + objxy[y*2];
-				ind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k);
-				if(ind[x*countOnes + y] >= max_size)
-					ind[x*countOnes + y] = 0;
-			}
-			likelihood[x] = 0;
-			for(y = 0; y < countOnes; y++)
-				likelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0;
-			likelihood[x] = likelihood[x]/((double) countOnes);
-		}
-		long long likelihood_time = get_time();
-		printf("TIME TO GET LIKELIHOODS TOOK: %f\n", elapsed_time(error, likelihood_time));
-		// update & normalize weights
-		// using equation (63) of Arulampalam Tutorial
-		#pragma omp parallel for shared(Nparticles, weights, likelihood) private(x)
-		for(x = 0; x < Nparticles; x++){
-			weights[x] = weights[x] * exp(likelihood[x]);
-		}
-		long long exponential = get_time();
-		printf("TIME TO GET EXP TOOK: %f\n", elapsed_time(likelihood_time, exponential));
-		double sumWeights = 0;
-		#pragma omp parallel for private(x) reduction(+:sumWeights)
-		for(x = 0; x < Nparticles; x++){
-			sumWeights += weights[x];
-		}
-		long long sum_time = get_time();
-		printf("TIME TO SUM WEIGHTS TOOK: %f\n", elapsed_time(exponential, sum_time));
-		#pragma omp parallel for shared(sumWeights, weights) private(x)
-		for(x = 0; x < Nparticles; x++){
-			weights[x] = weights[x]/sumWeights;
-		}
-		long long normalize = get_time();
-		printf("TIME TO NORMALIZE WEIGHTS TOOK: %f\n", elapsed_time(sum_time, normalize));
-		xe = 0;
-		ye = 0;
-		// estimate the object location by expected values
-		#pragma omp parallel for private(x) reduction(+:xe, ye)
-		for(x = 0; x < Nparticles; x++){
-			xe += arrayX[x] * weights[x];
-			ye += arrayY[x] * weights[x];
-		}
-		long long move_time = get_time();
-		printf("TIME TO MOVE OBJECT TOOK: %f\n", elapsed_time(normalize, move_time));
-		printf("XE: %lf\n", xe);
-		printf("YE: %lf\n", ye);
-		double distance = sqrt( pow((double)(xe-(int)roundDouble(IszY/2.0)),2) + pow((double)(ye-(int)roundDouble(IszX/2.0)),2) );
-		printf("%lf\n", distance);
-		//display(hold off for now)
-		
-		//pause(hold off for now)
-		
-		//resampling
-		
-		
-		CDF[0] = weights[0];
-		for(x = 1; x < Nparticles; x++){
-			CDF[x] = weights[x] + CDF[x-1];
-		}
-		long long cum_sum = get_time();
-		printf("TIME TO CALC CUM SUM TOOK: %f\n", elapsed_time(move_time, cum_sum));
-		double u1 = (1/((double)(Nparticles)))*randu(seed, 0);
-		#pragma omp parallel for shared(u, u1, Nparticles) private(x)
-		for(x = 0; x < Nparticles; x++){
-			u[x] = u1 + x/((double)(Nparticles));
-		}
-		long long u_time = get_time();
-		printf("TIME TO CALC U TOOK: %f\n", elapsed_time(cum_sum, u_time));
-		int j, i;
-		
-		#pragma omp parallel for shared(CDF, Nparticles, xj, yj, u, arrayX, arrayY) private(i, j)
-		for(j = 0; j < Nparticles; j++){
-			i = findIndex(CDF, Nparticles, u[j]);
-			if(i == -1)
-				i = Nparticles-1;
-			xj[j] = arrayX[i];
-			yj[j] = arrayY[i];
-			
-		}
-		long long xyj_time = get_time();
-		printf("TIME TO CALC NEW ARRAY X AND Y TOOK: %f\n", elapsed_time(u_time, xyj_time));
-		
-		//#pragma omp parallel for shared(weights, Nparticles) private(x)
-		for(x = 0; x < Nparticles; x++){
-			//reassign arrayX and arrayY
-			arrayX[x] = xj[x];
-			arrayY[x] = yj[x];
-			weights[x] = 1/((double)(Nparticles));
-		}
-		long long reset = get_time();
-		printf("TIME TO RESET WEIGHTS TOOK: %f\n", elapsed_time(xyj_time, reset));
-	}
-	free(disk);
-	free(objxy);
-	free(weights);
-	free(likelihood);
-	free(xj);
-	free(yj);
-	free(arrayX);
-	free(arrayY);
-	free(CDF);
-	free(u);
-	free(ind);
-}
-int main(int argc, char * argv[]){
-	
-	char* usage = "openmp.out -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles>";
-	//check number of arguments
-	if(argc != 9)
-	{
-		printf("%s\n", usage);
-		return 0;
-	}
-	//check args deliminators
-	if( strcmp( argv[1], "-x" ) ||  strcmp( argv[3], "-y" ) || strcmp( argv[5], "-z" ) || strcmp( argv[7], "-np" ) ) {
-		printf( "%s\n",usage );
-		return 0;
-	}
-	
-	int IszX, IszY, Nfr, Nparticles;
-	
-	//converting a string to a integer
-	if( sscanf( argv[2], "%d", &IszX ) == EOF ) {
-	   printf("ERROR: dimX input is incorrect");
-	   return 0;
-	}
-	
-	if( IszX <= 0 ) {
-		printf("dimX must be > 0\n");
-		return 0;
-	}
-	
-	//converting a string to a integer
-	if( sscanf( argv[4], "%d", &IszY ) == EOF ) {
-	   printf("ERROR: dimY input is incorrect");
-	   return 0;
-	}
-	
-	if( IszY <= 0 ) {
-		printf("dimY must be > 0\n");
-		return 0;
-	}
-	
-	//converting a string to a integer
-	if( sscanf( argv[6], "%d", &Nfr ) == EOF ) {
-	   printf("ERROR: Number of frames input is incorrect");
-	   return 0;
-	}
-	
-	if( Nfr <= 0 ) {
-		printf("number of frames must be > 0\n");
-		return 0;
-	}
-	
-	//converting a string to a integer
-	if( sscanf( argv[8], "%d", &Nparticles ) == EOF ) {
-	   printf("ERROR: Number of particles input is incorrect");
-	   return 0;
-	}
-	
-	if( Nparticles <= 0 ) {
-		printf("Number of particles must be > 0\n");
-		return 0;
-	}
-	//establish seed
-	int * seed = (int *)malloc(sizeof(int)*Nparticles);
-	int i;
-	for(i = 0; i < Nparticles; i++)
-		seed[i] = time(0)*i;
-	//malloc matrix
-	int * I = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);
-	long long start = get_time();
-	//call video sequence
-	videoSequence(I, IszX, IszY, Nfr, seed);
-	long long endVideoSequence = get_time();
-	printf("VIDEO SEQUENCE TOOK %f\n", elapsed_time(start, endVideoSequence));
-	//call particle filter
-	particleFilter(I, IszX, IszY, Nfr, seed, Nparticles);
-	long long endParticleFilter = get_time();
-	printf("PARTICLE FILTER TOOK %f\n", elapsed_time(endVideoSequence, endParticleFilter));
-	printf("ENTIRE PROGRAM TOOK %f\n", elapsed_time(start, endParticleFilter));
-	
-	free(seed);
-	free(I);
-	return 0;
-}
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/particle_filter particlefilter/particle_filter
--- ../original_src/rodinia_3.1/openmp/particlefilter/particle_filter	2021-07-27 19:40:03.120236000 -0700
+++ particlefilter/particle_filter	1969-12-31 16:00:00.000000000 -0800
@@ -1,45 +0,0 @@
-ELF          >    ô@     @       XT          @ 8 	 @ % "       @       @ @     @ @     ø      ø                   8      8@     8@                                          @       @     ¬D      ¬D                    ĞM      ĞM`     ĞM`     ø                           N       N`      N`     à      à                   T      T@     T@     D       D              Påtd   ä=      ä=@     ä=@                        Qåtd                                                  Råtd   ĞM      ĞM`     ĞM`     0      0             /lib64/ld-linux-x86-64.so.2          GNU                       GNU ªJM™a8ót__]®è€V]¦Œ                                                     6                                           ÿ                      Y                      k                                           H                      $                                          ´                      ~                                                                  	                     ï                      â                      ;                      ¢                                             .                       libm.so.6 __gmon_start__ _Jv_RegisterClasses __log_finite __exp_finite cos libgomp.so.1 GOMP_parallel_end omp_get_thread_num GOMP_atomic_end GOMP_parallel_start GOMP_atomic_start omp_get_num_threads libpthread.so.0 libc.so.6 __printf_chk __isoc99_sscanf puts time malloc gettimeofday strcmp __libc_start_main free GLIBC_2.15 GLIBC_2.2.5 GOMP_1.0 GLIBC_2.3.4 GLIBC_2.7                                      0   •‘–   ;     ui	   F        L      0   @$&   S     Ğ(&   R        Ø          ti	   [     ii   g     ui	   F      àO`                    P`                   P`                   P`                   P`                    P`                   (P`                   0P`                   8P`                   @P`        	           HP`        
-           PP`                   XP`                   `P`                   hP`                   pP`                   xP`                   €P`                   ˆP`                   Hƒìè_  èê  è%1  HƒÄÃÿ5G  ÿ%G  @ ÿ%G  h    éàÿÿÿÿ%G  h   éĞÿÿÿÿ%
-G  h   éÀÿÿÿÿ%G  h   é°ÿÿÿÿ%úF  h   é ÿÿÿÿ%òF  h   éÿÿÿÿ%êF  h   é€ÿÿÿÿ%âF  h   épÿÿÿÿ%ÚF  h   é`ÿÿÿÿ%ÒF  h	   éPÿÿÿÿ%ÊF  h
-   é@ÿÿÿÿ%ÂF  h   é0ÿÿÿÿ%ºF  h   é ÿÿÿÿ%²F  h   éÿÿÿÿ%ªF  h   é ÿÿÿÿ%¢F  h   éğşÿÿÿ%šF  h   éàşÿÿÿ%’F  h   éĞşÿÿAVAUATUSH‰óHƒì@ƒÿ	…(  H‹~¾ÿ<@ è:ÿÿÿ…À…  H‹{¾=@ è$ÿÿÿ…À…ü  H‹{(¾=@ èÿÿÿ…À…æ  H‹{8¾=@ èøşÿÿ…À…Ğ  H‹{1ÀH‰â¾=@ è-ÿÿÿƒÀ„  ƒ<$ Ö  H‹{ HT$1À¾=@ èÿÿÿƒÀ„¥  ƒ|$ ¹  H‹{0HT$ 1À¾=@ èÜşÿÿƒÀ„Õ  ƒ|$  œ  H‹{@HT$01À¾=@ è³şÿÿƒÀ„¿  ‹D$0…À“  H˜1íH<…    è}şÿÿH‰Ãë1ÿ1Àè_şÿÿA¯Ä‰«HƒÅ;l$0A‰ì|ãHcD$Hc<$H¯øHcD$ HÁçH¯øè<şÿÿH‰Å1Àè²  ‹L$ ‹T$I‰Ø‹4$H‰ïI‰Åè)  1Àè’  I‰ÄL)è¾N=@ óH*À¿   ¸   óY02  óZÀèşÿÿD‹L$0‹L$ I‰Ø‹T$‹4$H‰ïèÜ  1ÀèE  I‰ÆL)à¾f=@ óH*À¿   M)î¸   óYà1  óZÀè·ıÿÿóI*Æ¾=@ ¿   ¸   óY»1  óZÀè’ıÿÿH‰ßèªüÿÿH‰ïè¢üÿÿë
-¿(;@ è¶üÿÿHƒÄ@1À[]A\A]A^Ã¾ˆ;@ ¿   1ÀèVıÿÿëŞ¿=@ èŠüÿÿëÒ¿ =@ è~üÿÿëÆ¿1=@ èrüÿÿfë¸¾h;@ ¿   1Àèıÿÿë¥¿<@ èQüÿÿë˜¾¨;@ ¿   1Àèıüÿÿë…¾Ø;@ ¿   1Àèêüÿÿéoÿÿÿ®\$üL$ü@€  ®T$üÃ1íI‰Ñ^H‰âHƒäğPTIÇÀà9@ HÇÁP9@ HÇÇ 
-@ è3üÿÿôHƒìH‹µB  H…ÀtÿĞHƒÄÃUH‰åSHƒì€=xC   uK»ğM` H‹rC  HëèM` HÁûHƒëH9Øs$fD  HƒÀH‰MC  ÿÅèM` H‹?C  H9ØrâÆ+C  HƒÄ[]Ãfff.„     Hƒ=@@   UH‰åt¸    H…Àt]¿øM` ÿà]ÃATI‰üUS‹_èûÿÿ‰Åè*ûÿÿ‰Ú‰Á‰ØÁú÷ı1Ò¯è9İ•ÂĞ¯ÈÈ9ØOÃ9Á    ò*ËM‹$HcÑ‰Æ)Îòb/  MÑL‰ÂHÁâ<HÁê?9òGÖ…Ò‰Óò^ÁtƒÁ9ÖòA t_A‰óA)ÓD‰ßÑïA‰úEÒt,f(ĞI4Ø1ÒfÒf(Ê ƒÂf)HƒÆ9úrñDÑE9Ót HcÑIÑf.„     ƒÁòHƒÂ9Èñ[]A\Ãfff.„     ATUS‹o H‰ûè‘úÿÿA‰Äè9úÿÿ‰ê‰Á‰èÁúA÷ü1ÒD¯àA9ì•ÂĞ¯ÈÈ9èOÅ9Á}AH‹s‰ÍHcÉHÁá÷ÕèHÎHKH<Å   1À€    H‹SH‰H‹H‰HƒÀH9øuè[]A\Ãff.„     ATUSH‰ûHƒì‹o8èıùÿÿA‰Äè¥ùÿÿ‰ê‰Á‰èÁúA÷ü1ÒD¯àA9ì•ÂĞ¯ÈÈ9èNè9éf  L‹[(HcÁ‹S@ò%.  E1ÒòÜ-  MÃ„     …Ò>  H‹{L‰ÈH‹sL)ØL‹òòH‹sò,øò,Áò*×ò*È‰Ğ1ÒD  òFA‰ÌD¯àòXÂAÔMcäò,øòòXÁò,À¯{0ø‰Ï¯C4CDò*ÀfTÄò,ÀC‰ ‹C@D‹c<¯ø×HcÿI<¸D9'|	Ç    ‹C@ƒÂHƒÆ9Â|…ÀM‰•   ‰ÎL‰T$L‹c ¯ğòT$1ÒHcöM°€    Ic4HƒÂA‹4´~œîä   9Ğò*Îò*ÇòYÉòYÀò\ÁòYÃòXĞËòA‰Âò*ÈƒÁòAò^ÁòAIƒÁ9é…ÃşÿÿHƒÄ[]A\ÃIÇ    ‰ĞëË‰ÂëÇff.„     AUATI‰üUSHƒì‹_è+øÿÿ‰ÅèÔ÷ÿÿ‰Ú‰Á‰ØÁú÷ı1Ò¯è9İ•ÂĞ¯ÈÈ9ØOÃ9Á}O‰ËI‹l$M‹$$÷ÓHcÉØHÁá1ÛL,Å   HÍIÌf„     òAè%øÿÿòYD òD HƒÃL9ëuàHƒÄ[]A\A]ÃD  ATU‹oSH‰ûè‘÷ÿÿA‰Äè9÷ÿÿ‰ê‰Á‰èÁúA÷ü1ÒD¯àA9ì•ÂĞ¯ÈÈ9èOÅ9Á}9H‹3‰ÍHcÉ÷ÕèHÎHÅ   1À€    òò^CòHƒÀH9Ğuè[]A\Ã AVAUATUSH‰ûHƒì ‹o(è	÷ÿÿA‰Äè±öÿÿ‰ê‰Á‰èÁúfWÉA÷ü1Òf(ÙD¯àA9ì•ÂĞ¯ÈÈ9èNè9éD  L‹[HcÁA‰èHÅ    A)ÈL‹#L‹SML‰ÎHÁæ<HÁî?D9ÆAGğ…ö‰÷t!òAƒÁòAA9ğòYÙòAY„ë   E‰ÆA)öD‰ğÑèA‰ÅEí„’   fWäH4ı    MI<1ÒIñf(ìIğH÷1ö„     òAƒÆò4fADftf(ĞfAYHƒÂ9ÆfXèf(ÆfYÂfXàrÃf(ÄDéfäE9îòXÄòXÈf(ÅfíòXÅòXØtBHcÁ1ÒHÁàMI<LĞ€    òAĞò×òYĞòYĞHƒÂ49õòXÚòXÈÙò$ò\$èéõÿÿò\$ò$òX[ òXKò[ òKHƒÄ []A\A]A^éYõÿÿf„     ATUS‹oH‰ûè1õÿÿA‰ÄèÙôÿÿ‰ê‰Á‰èÁúA÷ü1ÒD¯àA9ì•ÂĞ¯ÈÈ9èOÅ9Á}<ò*ÅH‹{ò)  HcÑH×ò^ÈfD  ò*ÁƒÁòYÁòXòHƒÂ9Áuå[]A\ÃAUATUH‰ıSHƒì‹_0è«ôÿÿA‰ÄèSôÿÿ‰Ú‰Á‰ØÁúA÷ü1ÒD¯àA9Ü•ÂĞ¯ÈÈ9ØOÃ9Á    ‰ÏSÿL‹U÷×L‹M H‹u(øL‹mL‹e H‹mLÅ   HcÁHÁàLcÂHÕ   IÁà1ÿIÂIÁHÅD  …ÛòA:L‰À~)1Àf/v!°ë€    f/HPvH‰ĞH9ÈuíL‰ÀI‹T I‰9I‹H‰D= HƒÇL9ßu¯HƒÄ[]A\A]Ãfff.„     ATUH‰ıSHƒì‹_è­óÿÿA‰ÄèUóÿÿ‰Ú‰Á‰ØÁúfWÀA÷ü1ÒD¯àA9Ü•ÂĞ¯ÈÈ9ØNØ9Ù”   H‹} HcÁ‰Ú)ÊH4ÇH‰ğHÁà<HÁè?9ĞGÂ…ÀA‰ÂtƒÁ9ÂòtcA‰ÑA)ÁD‰ÈÑèA‰ÀEÀt8fWÉJ4Ö1Ò€    ƒÂfXHƒÆ9Ârñf(ÑDÁfÉE9ÁòXÑòXÂtHcÁHÇfƒÁòXHƒÂ9ËñHMH‹Uë
-€    H‰òH‰$H‰Ğò$òXÈòL$H‹t$ğH±1H9ÂH‰ÆuÕHƒÄ[]A\Ãfff.„     AWAVAUI‰ıATUSHƒìH‹_èwòÿÿ‰Åè òÿÿ‰Ú‰Á‰ØÁú÷ı1Ò¯è9İ•ÂĞ¯ÈÈ9ØOÃ9Áİ  H‹9  ò`&  M‹}Lcñ÷ÑJ,µ    IÁæÈòH*ÃIm M÷MuHÅ   E1äH‰D$8ò^ÈòL$ €    ‹E òC'¯ 9  
-9  H˜H‰ÂHÁú?H÷û‰U ‹9  A‰Õ¯Âé8  H˜H‰ÂHÁú?H÷ûò*Â‰U ‰T$òL$òYD$ fTî%  òY¾%  èQñÿÿòD$(òA*ÅòYD$ fTÈ%  èãñÿÿòY›%  ‹D$¯8  òL$t8  òXd%  òQÀòYD$(H˜H‰ÂHÁú?H÷ûòYf%  A‰ÕòXÈòC'òC&‰U ‹B8  òL$(¯Â#8  H˜H‰ÂHÁú?H÷ûò*Â‰U HƒÅòYD$ fT.%  òYş$  è‘ğÿÿòD$0òA*ÅòYD$ fT%  è#ñÿÿòYÛ$  òQÀòYD$0òXÙ$  òXÀòXD$(òC&IƒÄL;d$8…zşÿÿHƒÄH[]A\A]A^A_Ãff.„     Hƒì1öH‰çèğÿÿL‹$IiÀ@B HD$HƒÄÃffff.„     H)şóH*ÆóY€$  Ãffffff.„     ò,Àò*ÀÃ€    AU‹ATM‰Ì…ÀUS~oE‹1íE…É~^E‹$1Û1ÀE…ÛE‰ÚëA@ ƒÀE‰ÓD9Ğ}2A‰íE¯éAİE¯İAÃMcÛNšA9;uØA‰3E‹$ƒÀE‹D9ĞE‰Ó|ÎƒÃD9Ë|«‹ƒÅ9Å|–[]A\A]Ãff.„     HcöH‹¦6  H4·‹òH*É¯„6  n6  H˜H‰ÂHÁú?H÷ùò*Â‰ò^Áò€#  fTÁÃff.„     HcöSH4·Hƒì0H‹M6  ‹òS#  ¯,6  òH*Ñ6  H˜H‰ÂHÁú?H÷ù‰‹6  ‰Ó¯Âò5  H˜H‰ÂHÁú?H÷ùò*Â‰f)$òT$ò^ÂfTÁòYÍ"  è`îÿÿòD$(ò*ÃòT$f($ò^ÂfTÁèîîÿÿòY¦"  òQÀòYD$(HƒÄ0[ÃfD  AWM‰ÇAVAUATI‰ÌUH‰ÕSH‰ûHƒìH‹H‰t$8…ÀT  L‹5p5  ò@"  ‹ÇD$4    òI*Æò^ÈòL$…Ò  A‹$ÇD$0     E1í…Àå   D  ¯T$4T$0¯ÂDèAƒÅH˜Hƒ‹H‰L$‰D$$A‹¯ê4  Ô4  H˜H‰ÂHÁú?I÷şA‰‹Ï4  ‰Ö‰t$¯Â°4  H˜H‰ÂHÁú?I÷şò*ÂA‰òYD$fT¿!  òY!  è"íÿÿ‹t$òD$(ò*ÆòYD$fT–!  è±íÿÿòYi!  H‹L$òQÀòYD$(òYZ!  ò,ÀD$$‰A‹$‹U D9è ÿÿÿƒD$09T$0ŒÿÿÿH‹L$8‹ƒD$49D$4ŒÔşÿÿHƒÄH[]A\A]A^A_Ã@ 6Pÿ…Ò~zA‰ÁA¸   HcÒƒèA)ğL•    H…   ò*ÖA)ñD‰Æf.„     ò*ÎD‰Â1ÀòYÉ ò*ÂòYÀòXÁòQÀf/ĞvÇ   HƒÀƒÂH9Èu×ƒÆL×D9Îu¼óÃf.„     AUA‰òE1ÛATUS‹D$0‰ÓD‹l$(A)Â,E…ÒENÓ)Ã…ÛANÛD9ÅAOèDE9ÈEOÁD9Õ   E‰Ìò*ĞE¯ÊHcÉE¯åAÙE¯ÍMcäIÁäMcÉLÉMcÍLIÁá„     A9Ø~FD‰ĞL‰Ù)ğò*È‰ØòYÉf„     ‰Ç)×ò*ÇòYÀòXÁòQÀf/ĞvÇ   ƒÀLÉD9ÀuÕAƒÂMãA9êu©[]A\A]ÃfAWAVAUATA‰ÔUSHƒì@…É‰t$‰L$D‰D$L‰L$ Î   ‰ÈH‰|$0ÇD$    ¯ÂH˜HÁàH‰D$(HcÁH‰D$8D‹L$E…É‚   L‹l$8L‹|$0E1öIÁå1ÛE…äL‰ıëT@ ƒÃLíD9ãtEƒ} uï‹D$D‹D$‰Ú‹L$H‹|$ E‰áD‰öƒÃLí‰D$‹D$‰$è_şÿÿD9ãuÅf.„     AƒÆL|$(D;t$uƒD$HƒD$0‹D$9D$…WÿÿÿHƒÄ@[]A\A]A^A_Ã„     D	SAAÿ…À~nH˜A»   A)ÉA)ËH…    1öE‰Ú„     òA*ÊD‰ØH‰ùD  D‹E…Àtò*ÀD6ƒÆMcÀòBLÂòBÂƒÀHƒÁD9ÈuÑAƒÂHßE9Êuµ[Ã AWò*Â‰ğAVAUATUS‰ËHìˆ   ò÷  ‰D$P‰t$|‰Æ‰L$tòYÁ‰T$‰T$x¯òH‰|$@L‰D$hò,À¯ñò*Àò,Èò*D$PòYÁò,Àò*À‹D$¯Áò,ĞĞ¯ÃƒûH˜Ç‡     ¸   E1ÉA‰ĞD‹T$AÁøD‰Ç1×D)ÇA‰ÈAÁøD¯×D‰Ç1ÏD)ÇD×¯ûÇLcÇIÁà9şL‰ÏIOøL‹D$@ƒÀƒÁƒê9ØAÇ8   u§Hc|$PHcD$LcÃL‰D$8H¯øHÁçI¯øèáèÿÿH‰D$ D‹t$D‹D$P‹T$PH‹|$@òÙ  HÇD$H    D¯óAƒÀ‰\$TƒÂH‰|$`D‰D$\‰T$pMcöIÁæD‹l$PE…í‡  D‹D$H‹T$`H‹|$8D‹|$ÇD$   AƒÀH‰T$HÁçAƒÇD‰D$X‹D$…À/  ‹D$‹T$pA¸	   D‹l$Aƒè	H‹\$A»   D‰D$0ƒè
-ƒê‰D$Aƒí‰T$(ëD  AƒÃHûE9û„ß   ƒ;uëD‹L$AköD‹d$A¸    ‹t$XE…ÉD‹L$0DIL$…íD‰àANèD9d$PD‹d$(DMàƒîD9\$AMóE9á}‹D$H‹T$ ECûA¯Áè¯D$TH˜HD$HL‚f9î~GD‰ÈL‰ÒD)èò*È‰èòYÉf„     ‰ÁD)Áò*ÁòYÀòXÁòQÀf/ĞvÇ   ƒÀHú9ğuÕAƒÁMòE9áu©AƒÃHûE9û…!ÿÿÿƒD$Lt$D‹D$\D9D$…«şÿÿHƒD$HHƒD$`‹D$H9D$TQşÿÿ‹\$TD‹d$PE…är  ‹D$L‹|$ H‹|$@L‹t$8HÇD$    ÇD$    ¯ÃL)ÿIÁæH‰|$0H˜H‰D$(HÁàH‰D$‹l$…íï   H‹|$0L‹d$L‰ş1íLÿ…Û½   H‰ğ‰ÚƒàHÁèH÷Øƒà9ØFĞ…ÒA‰Ñ„à  1ÀfD  ‹†‰‡HHƒÀ9Âwï9Ót~A‰İA)ÕE‰èAÁèF…    E…Ût1IÁá1À1ÒNIùffAoƒÂóAHƒÀD9ÂrèDÙE9İt3LcÁL‹L$@1ÀMàIÁàMÁLD$ €    A‹€A‰HƒÀ9ÓíƒÅLöL÷Ld$8;l$…#ÿÿÿƒD$L|$L‹D$(‹T$PLD$9T$…ãşÿÿH‹|$ è©äÿÿH‹|$@H‹t$8E1ÀD‹T$I‰ùHÁæ1ÉE…ÒL‰Ê~91À…Ûë&fD  HƒÀ9Ã~D‹‚E…ÛuïÇ‚d   HƒÀ9ÃèƒÁHòD9ÑuÇAƒÀLL$D;D$Pu­H‹t$8D‹L$E1ÀHÁæ1ÉE…ÉH‰ú~:1À…Ûë'f.„     HƒÀ9Ã~ƒ<‚uòÇ‚ä   HƒÀ9ÃëƒÁHòD9ÉuÆAƒÀH|$D;D$Pu¬L‹D$hH‹|$@HL$tHT$xHt$|èúõÿÿHÄˆ   []A\A]A^A_Ã1Éé6şÿÿH‹|$ è—ãÿÿë½Hc|$PHcD$HcÓH‰T$8H¯øHÁçH¯úè2äÿÿ…ÛH‰D$ DıÿÿéDûÿÿ…ÒfWÀ~Fò  1ÀfD  Hc†HƒÀ‹DAœéä   9Âò*ÑòA*ÈòYÒòYÉò\ÊòYËòXÁÊóÃ…ö~1Àf/wëfHƒÇf/vƒÀ9ğuïFÿóÃf.„     ƒøÿtìóÃf„     9Ö¸ÿÿÿÿ~*é„   f…ÀtHòTÏøf/Âw<f/Ğt:f/Èv$P9Ö$‰Ğ)ğ‰ÁÁéÈÑøğHcÈòÏf/ÈsÀpÿ9Ö~Ü¸ÿÿÿÿóÃf…À~øf/ÂHTÏğtëë€    Hƒêf/BuƒèuğóÃfD  óÃóÃfff.„     AWAVAUATE‰ÌUSHìX  H‰|$xH¼$@  ‰t$p1ö‰T$@‰L$DL‰D$8èGâÿÿò*D$@òYÑ  H‹œ$@  ¿D  Hië@B H¬$H  ò,Àò*D$pòY£  ò*Èò,ÀòL$hò*ÈòL$Hè^âÿÿ1ÒÇ@   I‰ÇÇ@   Ç@   Ç@   Ç@   Ç@(   Ç@,   Ç@0   Ç@4   Ç@8   Ç@<   Ç@@   Ç@H   Ç@L   Ç@P   Ç@T   Ç@X   Ç@\   Ç@`   Ç@d   Ç@h   Ç@l   Ç@p   Ç@t   Ç@x   Ç@|   Ç€€      Ç€„      Ç€ˆ      Ç€Œ      Ç€      Ç€”      Ç€˜      Ç€œ      Ç€       Ç€¤      Ç€¨      Ç€¬      Ç€°      Ç€´      Ç€¸      Ç€¼      Ç€À      Ç€Ä      Ç€È      Ç€Ì      Ç€Ğ      Ç€Ô      Ç€Ø      Ç€Ü      Ç€à      Ç€ä      Ç€è      Ç€ì      Ç€ğ      Ç€ô      Ç€ø      Ç€      Ç€     Ç€     Ç€     Ç€     Ç€     Ç€     Ç€(     Ç€,     Ç€0     Ç€4     ƒ8Ç€8     ”ÂAƒBEÂPƒÀAƒEÂAƒ PEĞAƒ$BEÂPƒÀAƒDEÂP-ƒÀ.Aƒ¿ü   EÂPƒÀAƒ¿  EÂAƒ¿   PEĞAƒ¿$  BEÂPƒÀAƒ¿<  EÂAƒ¿@  HEÈ<	‰L$t‰L$HcÿHÁçè>ßÿÿ‹L$I‰ÆL‰ú¾üÿÿÿ1ÀD  D‹E…Ût"ò*Æ< Iº      ÀƒÀHcÿM‰şòADşD‹JE…Ét"ò*Æ< I¸      ÀƒÀHcÿM‰şòADş‹z…ÿt"ò*Æ< I½       ÀƒÀHcÿM‰,şòADş‹Z…Ût"ò*Æ< I»      ğ¿ƒÀHcÿM‰şòADşD‹RE…Òtò*Æ< ƒÀHcÿIÇş    òADşD‹JE…Ét"ò*Æ< I¸      ğ?ƒÀHcÿM‰şòADşD‹jE…ít"ò*Æ< H»       @ƒÀHcÿI‰şòADşD‹ZE…Ût"ò*Æ< Iº      @ƒÀHcÿM‰şòADşD‹J E…Ét"ò*Æ< I¸      @ƒÀHcÿM‰şòADşƒÆHƒÂ$ƒş…xşÿÿH¼$@  1ö‰L$èİÿÿH‹„$@  ¾H:@ ¿   HiØ@B Hœ$H  H‰ØH)èóH*À¸   óY”  ÀZÀèiİÿÿIcüHÁçè=İÿÿH´$0  1Ò¿à@ H‰„$0  D‰¤$8  èiÜÿÿH¼$0  èLáÿÿèwÜÿÿ‹”$8  H¼$@  1öH‹¬$0  ‰T$0èuÜÿÿH‹„$@  ¾(<@ ¿   LiÈ@B LŒ$H  L‰ÈL‰L$H)ØóH*À¸   óYç  ÀZÀè¼ÜÿÿHcT$0HÕ    H‰T$H‰ÇH‰D$(è}ÜÿÿH‹|$(H‰D$`ènÜÿÿH‹|$(H‰$è`ÜÿÿH‹|$(H‰D$ èQÜÿÿH‹|$(I‰ÅèDÜÿÿH‹|$(I‰Äè7ÜÿÿH‹|$(H‰Ãè*ÜÿÿH‹T$‹L$H‰D$XH<•    HcÉH¯ùèÜÿÿH‹t$ òL$H‹T$0L‹$¿Ğ@ òŒ$`  H‰D$PòL$hH‰´$p  H´$`  ‰”$€  1ÒòŒ$h  L‰„$x  èıÚÿÿH¼$`  èĞàÿÿèÛÿÿH‹Œ$p  L‹„$x  H¼$@  ‹”$€  1öH‰L$L‰$‰T$èøÚÿÿH‹„$@  L‹L$¾E<@ ¿   HiÀ@B H„$H  L)ÈóH*À¸   óYm  ÀZÀèBÛÿÿƒ|$D‹T$H‹L$L‹$7
-  ‹D$pòD$H¯D$@L‰¼$˜   Aº   H‰L$(L‰t$HA‰×L‰D$0¯D$D‰D$pò,Àò*ÈòŒ$   H¼$@  1öD‰T$ è<ÚÿÿH‹„$@  H‹T$(H´$  ¿à@ D‰¼$¨  Liğ@B H‹D$8H‰”$˜  1ÒL´$H  H‰„$  H‹D$0H‰„$   è¢ÙÿÿH¼$  è…çÿÿè°ÙÿÿH‹”$  H‹Œ$   H¼$@  D‹„$¨  1öH‰T$8H‹”$˜  H‰L$D‰$H‰T$èÙÿÿH‹”$@  ¾b<@ ¿   Liú@B L¼$H  L‰øL)ğóH*À¸   óY  ÀZÀèÚÙÿÿH‹D$PH‹T$H´$    D‹T$ H‹L$¿`@ D‹$H‰„$    H‹D$HH‰”$°   H‹T$xD‰”$ä   H‰Œ$¸   H‰„$¨   H‹D$`H‰”$À   ‹T$@D‰„$Ø   H‰„$È   ‹D$D‰”$Ğ   ‹T$p‰„$Ô   ‹D$t‰”$Ü   1Ò‰„$à   ècØÿÿH¼$    èÆŞÿÿèqØÿÿH‹„$    H‹”$À   H¼$@  L‹Œ$°   L‹„$¸   1öH‹Œ$È   H‰D$PH‹„$¨   H‰T$x‹”$Ğ   L‰L$L‰$H‰D$H‹„$Ô   ‰T$@‹”$Ø   H‰L$‰D$D‹„$Ü   ‰T$‰D$p‹„$à   ‰D$t‹„$ä   ‰D$hèó×ÿÿH‹Œ$@  ¾h:@ ¿   Liñ@B L´$H  L‰ğL)øóH*À¸   óYj  ÀZÀè?Øÿÿ‹T$H‹L$H´$°  ¿0@ H‰¬$¸  ‰”$À  1ÒH‰Œ$°  è;×ÿÿH¼$°  ènßÿÿèI×ÿÿH‹”$¸  H‹„$°  H¼$@  1ö‹¬$À  H‰T$H‰D$`è9×ÿÿH‹´$@  ¿   Liş@B ¾~<@ L¼$H  L‰øL)ğóH*À¸   óY°  ÀZÀè…×ÿÿH‹T$H´$Ğ  ¿°@ ‰¬$à  HÇ„$Ø      H‰”$Ğ  1ÒèÖÿÿH¼$Ğ  è4ãÿÿèÖÿÿH‹”$Ø  H‹Œ$Ğ  H¼$@  1öD‹´$à  H‰T$H‰L$è~ÖÿÿH‹¼$@  ¾˜<@ Hiï@B ¿   H¬$H  H‰èL)øóH*À¸   óYõ
-  ÀZÀèÊÖÿÿH‹T$H‹L$H´$ğ  ¿Ğ@ D‰´$   H‰”$ø  1ÒH‰Œ$ğ  èÄÕÿÿH¼$ğ  è—ŞÿÿèÒÕÿÿH‹”$ğ  H¼$@  1öD‹´$   H‰T$èÎÕÿÿL‹„$@  ¾:@ ¿   Miø@B L¼$H  L‰øH)èóH*À¸   óYE
-  ÀZÀèÖÿÿH‹T$L‹$H´$0  L‹L$¿P@ D‰´$X  HÇ„$P      HÇ„$H      H‰”$0  1ÒL‰„$8  L‰Œ$@  èğÔÿÿH¼$0  èCŞÿÿèşÔÿÿòŒ$P  H‹”$@  H‹„$8  H¼$@  1öòL$(H‹¬$0  D‹´$X  òŒ$H  H‰”$ˆ   H‰„$€   òL$0èÁÔÿÿL‹Œ$@  ¾¶<@ ¿   IiÑ@B H”$H  H‰ĞH‰T$L)øóH*À¸   óY3	  ÀZÀèÕÿÿòD$(¾Ô<@ ¿   ¸   èîÔÿÿòD$0¾İ<@ ¿   ¸   èÔÔÿÿò*D$@òYÎ  ¾Ø<@ ¿   òL$(ò,Àò*Àò,Àò*À¸   ò\ÈòD$0ò\„$   òYÉòYÀòXÁòQÀèyÔÿÿH‹E AƒşH‹T$H‰~1AFşHÅ   1Àf„     òòXDòDHƒÀH9ÈuæH¼$@  1öH‰T$è’ÓÿÿH‹„$@  H‹T$¾¸:@ ¿   Liø@B L¼$H  L‰øH)ĞóH*À¸   óY  ÀZÀèÙÓÿÿH‹T$8H‹Í  H´$  ¿0@ ‹òH*É¯¢  Œ  H˜H‰ÂHÁú?H÷ùH‹D$8ò*Â‰H‹D$X1ÒD‰´$   H‰„$  ò^ÁòA*ÎfT}  ò^Áò„$  è‹ÒÿÿH¼$  è¾İÿÿè™ÒÿÿH‹Œ$  ‹”$   H¼$@  1ö‰T$H‰L$è’ÒÿÿH‹„$@  ¾æ<@ ¿   Liğ@B L´$H  L‰ğL)øóH*À¸   óY	  ÀZÀèŞÒÿÿH‹„$ˆ   ‹T$H´$ğ   H‹L$¿°@ L‰¤$  L‰¬$  H‰œ$  H‰„$ğ   H‹„$€   ‰”$   1ÒH‰Œ$   H‰„$ø   èªÑÿÿH¼$ğ   è]İÿÿè¸ÑÿÿH‹„$ø   H‹”$ğ   H¼$@  1öD‹¼$   L‹¤$  L‹¬$  H‹œ$  H‰D$0H‹„$   H‰T$(H‰D$Xè‚ÑÿÿH‹„$@  ¾Ø:@ ¿   HiĞ@B H”$H  H‰ĞH‰T$L)ğóH*À¸   óYô  ÀZÀèÉÑÿÿE…ÿH‹T$~GòA*ÇH‹L$(ò…  L‹D$01Àò^Èf(ÁfD  I‹tÅ I‰4ÀI‹4ÄH‰4ÁòDÅ HƒÀA9ÇàH¼$@  1öH‰T$èÔĞÿÿH‹„$@  H‹T$¾;@ ¿   HiÀ@B H„$H  H)ĞóH*À¸   óYI  ÀZÀèÑÿÿD‹T$hAƒÂD9T$D*öÿÿL‹¼$˜   H‹L$(L‹t$HL‹D$0L‰ÿH‰L$L‰$èĞÿÿL‰÷èúÏÿÿH‰ïèòÏÿÿH‹|$`èèÏÿÿL‰ïèàÏÿÿL‰çèØÏÿÿL‹$L‰ÇèÌÏÿÿH‹L$H‰Ïè¿ÏÿÿH‰ßè·ÏÿÿH‹|$Xè­ÏÿÿH‹|$Pè£ÏÿÿHÄX  []A\A]A^A_ÃH‰l$ØL‰d$àH-w  L%h  L‰l$èL‰t$ğL‰|$øH‰\$ĞHƒì8L)åA‰ıI‰öHÁıI‰×è#ÏÿÿH…ít1Û@ L‰úL‰öD‰ïAÿÜHƒÃH9ëuêH‹\$H‹l$L‹d$L‹l$ L‹t$(L‹|$0HƒÄ8Ã€    óÃUH‰åSHƒìH‹Ø  Hƒøÿt»ØM` D  HƒëÿĞH‹HƒøÿuñHƒÄ[]ÃHƒìèÓÿÿHƒÄÃ                TIME TO GET NEIGHBORS TOOK: %f
- TIME TO GET LIKELIHOODS TOOK: %f
-       TIME TO NORMALIZE WEIGHTS TOOK: %f
-     TIME TO CALC CUM SUM TOOK: %f
-  TIME TO CALC NEW ARRAY X AND Y TOOK: %f
-        TIME TO RESET WEIGHTS TOOK: %f
- openmp.out -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles>        ERROR: dimX input is incorrect  ERROR: dimY input is incorrect  ERROR: Number of frames input is incorrect      ERROR: Number of particles input is incorrect   Number of particles must be > 0 TIME TO GET WEIGHTSTOOK: %f
- TIME TO SET ARRAYS TOOK: %f
- TIME TO SET ERROR TOOK: %f
- TIME TO GET EXP TOOK: %f
- TIME TO SUM WEIGHTS TOOK: %f
- TIME TO MOVE OBJECT TOOK: %f
- XE: %lf
- YE: %lf
- TIME TO CALC U TOOK: %f
- -x -y -z -np %d dimX must be > 0 dimY must be > 0 number of frames must be > 0 VIDEO SEQUENCE TOOK %f
- PARTICLE FILTER TOOK %f
- ENTIRE PROGRAM TOOK %f
-        ğ?{®Gáz”?-DTû!@       À      @      ğ¿      à?ÿÿÿÿÿÿÿ        ½7†5;      ìÊÿÿ  Ìÿÿ$  üÎÿÿ¬  üÏÿÿD  ìĞÿÿt  |Ñÿÿ¤  LÓÿÿÜ  ìÓÿÿ  lÔÿÿD  LÖÿÿŒ  ÌÖÿÿ¼  Ì×ÿÿô  üØÿÿ,  <Ûÿÿ|  lÛÿÿ”  ŒÛÿÿ¬  œÛÿÿÄ  ,Üÿÿü  |Üÿÿ  <İÿÿ4  ÌŞÿÿ„  \ßÿÿœ  <àÿÿÔ  Láÿÿ  Ìáÿÿ<  œçÿÿŒ  ìçÿÿ¤  ,èÿÿ¼  ÌèÿÿÔ  lûÿÿl  üûÿÿ”         zR x  $      ÈÉÿÿ0   FJw€ ?;*3$"    ,   D   °Îÿÿä    BŒD†A ƒÙAB      ,   t   pÏÿÿ…    BŒA†A ƒ}AB      4   ¤   ĞÏÿÿÅ   BŒA†A ƒG0¦
- AABA    4   Ü   hÑÿÿ›    BBŒD †A(ƒD0‡(A ABB,     ĞÑÿÿ}    BŒA†D ƒrAB      D   D   Òÿÿ×   BBB ŒA(†A0ƒGP»0A(A BBB       ,   Œ  ¸Óÿÿ€    BŒA†A ƒxAB      4   ¼  Ôÿÿô    BBŒA †D(ƒD0à(A ABB4   ô  ĞÔÿÿ$   BŒA†D ƒD0 AAB       L   ,  ÈÕÿÿ5   BBB E(ŒA0†A8ƒD€8A0A(B BBB         |  ¸×ÿÿ#    D ^    ”  Ğ×ÿÿ              ¬  Ø×ÿÿ	           4   Ä  Ğ×ÿÿ…    BDŒF †A(ƒr ABB         ü  (ØÿÿE                `Øÿÿº    DƒH@¬AL   4   ÙÿÿŒ   BEB B(ŒD0†D8ƒG€g8A0A(B BBB         „  @Úÿÿ†           4   œ  ¸ÚÿÿŞ    BHŒA †A(ƒÌ ABB      D   Ô  `Ûÿÿ   BBB B(ŒD0†A8ƒDxì8A0A(B BBB     (Üÿÿ}    Eƒw      L   <  ˆÜÿÿĞ   BHB B(ŒA0†A8ƒIÀd
-8A0A(B BBBA      Œ  âÿÿP              ¤  @âÿÿ7              ¼  hâÿÿ”           L   Ô  ğâÿÿŸ   BBB B(ŒD0†A8ƒG€8A0A(B BBB      D   $  ğÅÿÿÛ   BBB ŒA(†A0ƒGp?
-0C(A BBBA    $   l  øôÿÿ‰    QŒ†_@ƒX      ”  `õÿÿ              ¬  HÈÿÿ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   à@     ÿÿÿÿÿÿÿÿ        ÿÿÿÿÿÿÿÿ                                     L              È              Ø              ¸@            (:@            ĞM`                   õşÿo    ˜@            °@            ¸@     
-       q                                          èO`            °                           @            ğ@                   	              şÿÿo    P@     ÿÿÿo           ğÿÿo    "@                                                                                                              N`                     æ@     ö@     	@     	@     &	@     6	@     F	@     V	@     f	@     v	@     †	@     –	@     ¦	@     ¶	@     Æ	@     Ö	@     æ	@     ö	@                     90              mNÆA            ÿÿÿ    GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3 ,             à@                            j                U                              (à@     ó@     wf      Uf   	‘t”
-@€!Ÿ     %RU  .:;'@
-  4 :;I
-  $ >   i    K   û      ../../../src/libgcc/../gcc/config/i386  crtfastmath.c     	à@     (,ZÊ GNU C 4.6.3 mxcsr set_fast_math ../../../src/libgcc/../gcc/config/i386/crtfastmath.c /build/buildd/gcc-4.6-4.6.3/build/x86_64-linux-gnu/libgcc unsigned int à@     ó@                      .symtab .strtab .shstrtab .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .ctors .dtors .jcr .dynamic .got .got.plt .data .bss .comment .debug_aranges .debug_info .debug_abbrev .debug_line .debug_str .debug_ranges                                                                                8@     8                                    #             T@     T                                     1             t@     t      $                              D   öÿÿo       ˜@     ˜                                   N             ¸@     ¸      ø                          V             °@     °      q                             ^   ÿÿÿo       "@     "      *                            k   şÿÿo       P@     P                                   z             ğ@     ğ                                  „             @           °                                       ¸@     ¸                                    ‰             Ğ@     Ğ      0                            ”              
-@      
-      (0                             š             (:@     (:                                                  @:@     @:      ¤                             ¨             ä=@     ä=                                   ¶             è>@     è>      Ä                             À             ĞM`     ĞM                                    Ì             ØM`     ØM                                    Ó             èM`     èM                                    Ú             øM`     øM                                    ß              N`      N      à                           è             àO`     àO                                   í             èO`     èO      ¨                             ö             P`     P      8                              ü             ÈP`     ÈP                                         0               ÈP      *                             
-                     òP      0                                                   "Q      n                              %                     Q      E                              3                     ÕQ      m                              ?     0               BR      œ                             J                     ŞR                                                           şR      X                                                   ˜]            $   A                 	                      ¨h      [                                                           8@                   T@                   t@                   ˜@                   ¸@                   °@                   "@                   P@                  	 ğ@                  
- @                   ¸@                   Ğ@                    
-@                   (:@                   @:@                   ä=@                   è>@                   ĞM`                   ØM`                   èM`                   øM`                    N`                   àO`                   èO`                   P`                   ÈP`                                                                                                                                                       !                       @                 ñÿ                     ØM`             *     èM`             8     øM`             E     @@             [     ÈP`            j     ĞP`            x     °@                 ñÿ                „     àM`             ‘     ¨D@             Ÿ     øM`             «     ğ9@             Á    ñÿ                Ú     à@     ä       ó     Ğ@     …           `@     Å      %    0@     ›       >    Ğ@     }       W    P@     ×      p    0@     €       ‰    °@     ô       ¢    °@     $      »    à@     5      Ô   ñÿ                â    à@            ğ     ØM`                  N`             
-     ĞM`                 èO`             3    à9@            C                     U    €%@     P       g     P`             r     @     Œ      {                     ™                     «    P@            ¸    €@     …       ¾   ñÿÈP`             Å    0@     }       Ò                     î                     
-    (:@                                  *    Ğ%@     7       4   ğM`             A                     R                     q     @     #       z    P`             ‡                     ›                     ¸                     Ò                      á   ˜P`             î    @:@            ı                         p@     	           P9@     ‰       +                     ?                     Z     P`            \    °P`            ^    ÀP`            `   ñÿØP`             e    ô@             l     @           z    °@     Ğ      ˆ   ñÿÈP`             ”     
-@     Û      ™                     ³                     Ì                     è    @     E       î    °@     †       ø    `@     º       ş                          &@     ”           °&@     Ÿ      .    @@     Ş       <    ¸@             B                      call_gmon_start crtstuff.c __CTOR_LIST__ __DTOR_LIST__ __JCR_LIST__ __do_global_dtors_aux completed.6531 dtor_idx.6533 frame_dummy __CTOR_END__ __FRAME_END__ __JCR_END__ __do_global_ctors_aux ex_particle_OPENMP_seq.c particleFilter._omp_fn.0 particleFilter._omp_fn.1 particleFilter._omp_fn.3 particleFilter._omp_fn.4 particleFilter._omp_fn.6 particleFilter._omp_fn.7 particleFilter._omp_fn.8 particleFilter._omp_fn.9 particleFilter._omp_fn.5 particleFilter._omp_fn.2 crtfastmath.c set_fast_math __init_array_end _DYNAMIC __init_array_start _GLOBAL_OFFSET_TABLE_ __libc_csu_fini free@@GLIBC_2.2.5 calcLikelihoodSum data_start addNoise GOMP_parallel_start@@GOMP_1.0 puts@@GLIBC_2.2.5 elapsed_time setIf _edata getneighbors GOMP_parallel_end@@GOMP_1.0 omp_get_thread_num@@OMP_1.0 _fini gettimeofday@@GLIBC_2.2.5 findIndex __DTOR_END__ cos@@GLIBC_2.2.5 __libc_start_main@@GLIBC_2.2.5 get_time __data_start strcmp@@GLIBC_2.2.5 omp_get_num_threads@@OMP_1.0 GOMP_atomic_end@@GOMP_1.0 __gmon_start__ __dso_handle _IO_stdin_used time@@GLIBC_2.2.5 roundDouble __libc_csu_init malloc@@GLIBC_2.2.5 __isoc99_sscanf@@GLIBC_2.7 C A M _end _start imdilate_disk videoSequence __bss_start main __printf_chk@@GLIBC_2.3.4 __exp_finite@@GLIBC_2.15 GOMP_atomic_start@@GOMP_1.0 randu strelDisk randn _Jv_RegisterClasses findIndexBin particleFilter dilate_matrix _init __log_finite@@GLIBC_2.15 
\ No newline at end of file
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/particlefilter.cpp particlefilter/particlefilter.cpp
--- ../original_src/rodinia_3.1/openmp/particlefilter/particlefilter.cpp	1969-12-31 16:00:00.000000000 -0800
+++ particlefilter/particlefilter.cpp	2021-07-27 20:39:59.684965000 -0700
@@ -0,0 +1,467 @@
+#include<bits/stdc++.h>
+#include <cmath>
+#include <executionTime.h>
+#include <datautils.hpp>
+#include <approx.h>
+#include <omp.h>
+#define PI 3.1415926535897932
+
+#define DOUBLE 0
+
+/**
+  @var M value for Linear Congruential Generator (LCG); use GCC's value
+  */
+long M = INT_MAX;
+/**
+  @var A value for LCG
+  */
+int A = 1103515245;
+/**
+  @var C value for LCG
+  */
+int C = 12345;
+
+void setIf(int testValue, int newValue, int * array3D, int * dimX, int * dimY, int * dimZ){
+    int x, y, z;
+    for(x = 0; x < *dimX; x++){
+        for(y = 0; y < *dimY; y++){
+            for(z = 0; z < *dimZ; z++){
+                if(array3D[x * *dimY * *dimZ+y * *dimZ + z] == testValue)
+                    array3D[x * *dimY * *dimZ + y * *dimZ + z] = newValue;
+            }
+        }
+    }
+}
+
+double randu(int * seed, int index)
+{
+    int num = A*seed[index] + C;
+    seed[index] = num % M;
+    return fabs(seed[index]/((double) M));
+}
+
+double randn(int * seed, int index){
+    int num = A*seed[index] + C;
+    seed[index]  = num % M;
+    double u = fabs(seed[index]/((double)M));
+    num = A * seed[index] + C;
+    seed[index]  = num % M;
+    double v = fabs(seed[index]/((double)M));
+    double cosine = cos(2.0*PI*v);
+    double rt = -2.0*log(u);
+    return sqrt(rt)*cosine;
+}
+
+
+double noise_randn(int * seed, int index){
+    int num = A*seed[index] + C;
+    seed[index]  = num % M;
+    double u = fabs(seed[index]/((double)M));
+    num = A * seed[index] + C;
+    seed[index]  = num % M;
+    double v = fabs(seed[index]/((double)M));
+    double cosine = cos(2.0*PI*v);
+    double rt = -2.0*log(u);
+    return sqrt(rt)*cosine;
+}
+
+
+void addNoise(int * array3D, int * dimX, int * dimY, int * dimZ, int * seed){
+    int x, y, z;
+    for(x = 0; x < *dimX; x++){
+        for(y = 0; y < *dimY; y++){
+            for(z = 0; z < *dimZ; z++){
+                array3D[x * *dimY * *dimZ + y * *dimZ + z] = array3D[x * *dimY * *dimZ + y * *dimZ + z] + (int)(5.0*noise_randn(seed, 0));
+            }
+        }
+    }
+}
+
+void strelDisk(int * disk, int radius)
+{
+    int diameter = radius*2 - 1;
+    int x, y;
+    for(x = 0; x < diameter; x++){
+        for(y = 0; y < diameter; y++){
+            double distance = sqrt(pow((double)(x-radius+1),2.0) + pow((double)(y-radius+1),2.0));
+            if(distance < radius)
+                disk[x*diameter + y] = 1;
+        }
+    }
+}
+
+void dilate_matrix(int * matrix, int posX, int posY, int posZ, int dimX, int dimY, int dimZ, int error)
+{
+    int startX = posX - error;
+    while(startX < 0)
+        startX++;
+    int startY = posY - error;
+    while(startY < 0)
+        startY++;
+    int endX = posX + error;
+    while(endX > dimX)
+        endX--;
+    int endY = posY + error;
+    while(endY > dimY)
+        endY--;
+    int x,y;
+    for(x = startX; x < endX; x++){
+        for(y = startY; y < endY; y++){
+            double distance = sqrt( pow((double)(x-posX),2) + pow((double)(y-posY),2) );
+            if(distance < error)
+                matrix[x*dimY*dimZ + y*dimZ + posZ] = 1;
+        }
+    }
+}
+
+void imdilate_disk(int * matrix, int dimX, int dimY, int dimZ, int error, int * newMatrix)
+{
+    int x, y, z;
+    for(z = 0; z < dimZ; z++){
+        for(x = 0; x < dimX; x++){
+            for(y = 0; y < dimY; y++){
+                if(matrix[x*dimY*dimZ + y*dimZ + z] == 1){
+                    dilate_matrix(newMatrix, x, y, z, dimX, dimY, dimZ, error);
+                }
+            }
+        }
+    }
+}
+
+void getneighbors(int * se, int numOnes, double * neighbors, int radius){
+    int x, y;
+    int neighY = 0;
+    int center = radius - 1;
+    int diameter = radius*2 -1;
+    for(x = 0; x < diameter; x++){
+        for(y = 0; y < diameter; y++){
+            if(se[x*diameter + y]){
+                neighbors[neighY*2] = (int)(y - center);
+                neighbors[neighY*2 + 1] = (int)(x - center);
+                neighY++;
+            }
+        }
+    }
+}
+
+void videoSequence(int * I, int IszX, int IszY, int Nfr, int * seed){
+    int k;
+    int max_size = IszX*IszY*Nfr;
+    int x0 = (int)round(IszY/2.0);
+    int y0 = (int)round(IszX/2.0);
+    I[x0 *IszY *Nfr + y0 * Nfr  + 0] = 1;
+
+    int xk, yk, pos;
+    for(k = 1; k < Nfr; k++){
+        xk = abs(x0 + (k-1));
+        yk = abs(y0 - 2*(k-1));
+        pos = yk * IszY * Nfr + xk *Nfr + k;
+        if(pos >= max_size)
+            pos = 0;
+        I[pos] = 1;
+    }
+
+    int * newMatrix = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);
+    imdilate_disk(I, IszX, IszY, Nfr, 5, newMatrix);
+    int x, y;
+    for(x = 0; x < IszX; x++){
+        for(y = 0; y < IszY; y++){
+            for(k = 0; k < Nfr; k++){
+                I[x*IszY*Nfr + y*Nfr + k] = newMatrix[x*IszY*Nfr + y*Nfr + k];
+            }
+        }
+    }
+    free(newMatrix);
+
+    setIf(0, 100, I, &IszX, &IszY, &Nfr);
+    setIf(1, 228, I, &IszX, &IszY, &Nfr);
+    addNoise(I, &IszX, &IszY, &Nfr, seed);
+}
+
+
+int findIndex(double * CDF, int lengthCDF, double value){
+    int index = -1;
+    int x;
+    for(x = 0; x < lengthCDF; x++){
+        if(CDF[x] >= value){
+            index = x;
+            break;
+        }
+    }
+    if(index == -1){
+        return lengthCDF-1;
+    }
+    return index;
+}
+
+int findIndexBin(double * CDF, int beginIndex, int endIndex, double value){
+    if(endIndex < beginIndex)
+        return -1;
+    int middleIndex = beginIndex + ((endIndex - beginIndex)/2);
+    /*check the value*/
+    if(CDF[middleIndex] >= value)
+    {
+        /*check that it's good*/
+        if(middleIndex == 0)
+            return middleIndex;
+        else if(CDF[middleIndex-1] < value)
+            return middleIndex;
+        else if(CDF[middleIndex-1] == value)
+        {
+            while(middleIndex > 0 && CDF[middleIndex-1] == value)
+                middleIndex--;
+            return middleIndex;
+        }
+    }
+    int start = middleIndex-1;
+    int end = endIndex;
+    if(CDF[middleIndex] > value){
+        start = beginIndex;
+        end = middleIndex+1;
+    }
+    return findIndexBin(CDF, start, end, value);
+}
+
+double *particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){
+
+    int max_size = IszX*IszY*Nfr;
+    //original particle centroid
+    double xe = round(IszY/2.0);
+    double ye = round(IszX/2.0);
+    double *positions = (double*) malloc(Nfr*2*sizeof(double));
+    memset(positions, 0, sizeof(double)*Nfr*2);
+    int count = 0;	
+    //expected object locations, compared to center
+    int radius = 5;
+    int diameter = radius*2 - 1;
+    int * disk = (int *)malloc(diameter*diameter*sizeof(int));
+    strelDisk(disk, radius);
+    int countOnes = 0;
+    int x, y;
+    for(x = 0; x < diameter; x++){
+        for(y = 0; y < diameter; y++){
+            if(disk[x*diameter + y] == 1)
+                countOnes++;
+        }
+    }
+    double * objxy = (double *)malloc(countOnes*2*sizeof(double));
+    getneighbors(disk, countOnes, objxy, radius);
+
+    //initial weights are all equal (1/Nparticles)
+    double * weights = (double *)malloc(Nparticles*2*sizeof(double));
+	#pragma omp parallel for shared(weights, Nparticles) private(x)
+    for(x = 0; x < Nparticles; x++){
+        weights[x] = 1/((double)(Nparticles));
+    }
+    //initial likelihood to 0.0
+    double * likelihood = (double *) malloc (sizeof(double)*Nparticles);
+    memset(likelihood, 0, sizeof(double)*Nparticles);
+
+    double * arrayX =(double *) malloc(Nparticles*sizeof(double));
+    memset(arrayX, 0, sizeof(double)*Nparticles);
+
+    double * arrayY =(double *) malloc(Nparticles*sizeof(double));
+    memset(arrayY, 0, sizeof(double)*Nparticles);
+
+    double * xj =(double *) malloc(Nparticles*sizeof(double));
+    memset(xj, 0, sizeof(double)*Nparticles);
+
+    double * yj = (double *)malloc(Nparticles*sizeof(double));
+    memset(yj, 0, sizeof(double)*Nparticles);
+
+    double * CDF =(double *) malloc(Nparticles*sizeof(double));
+    memset(CDF, 0, sizeof(double)*Nparticles);
+
+    double * u =(double *) malloc(sizeof(double)*Nparticles);
+    memset(u, 0, sizeof(double)*Nparticles);
+
+
+    int * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles);
+    memset(ind, 0, sizeof(int)*Nparticles*countOnes);
+	#pragma omp parallel for shared(arrayX, arrayY, xe, ye) firstprivate(Nparticles)
+    for(x = 0; x < Nparticles; x++){
+        arrayX[x] = xe;
+        arrayY[x] = ye;
+    }
+    int k;
+
+    int indX, indY;
+    for(k = 1; k < Nfr; k++){
+		#pragma omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)
+        for(x = 0; x < Nparticles; x++){
+            arrayX[x] += 1.0 + 5.0 *randn(seed, x);
+            arrayY[x] += -2.0 + 2.0 *randn(seed, x);
+        }
+        //@APPROX LABEL("LIKELIHOOD") INOUT(likelihood[0:Nparticles]) IN( indX, IszY, Nfr, indY) APPROX_TECH(MEMO_IN|MEMO_OUT|PERFO) 
+		#pragma omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)
+        for(x = 0; x < Nparticles; x++){
+            for(y = 0; y < countOnes; y++){
+                indX = round(arrayX[x]) + objxy[y*2 + 1];
+                indY = round(arrayY[x]) + objxy[y*2];
+                ind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k);
+                if(ind[x*countOnes + y] >= max_size)
+                    ind[x*countOnes + y] = 0;
+            }
+            likelihood[x] = 0.0;
+            for(y = 0; y < countOnes; y++)
+                likelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0;
+            likelihood[x] = likelihood[x]/((double) countOnes);
+        }
+
+		    #pragma omp parallel for shared(Nparticles, weights, likelihood) private(x)
+            for(x = 0; x < Nparticles; x++){
+                weights[x] = weights[x] * exp(likelihood[x]);
+            }
+
+            double sumWeights = 0.0;
+		    #pragma omp parallel for private(x) reduction(+:sumWeights)
+            for(x = 0; x < Nparticles; x++){
+                sumWeights += weights[x];
+            }
+
+		    #pragma omp parallel for shared(sumWeights, weights) private(x)
+            for(x = 0; x < Nparticles; x++){
+                weights[x] = weights[x]/sumWeights;
+            }
+
+        xe = 0.0;
+        ye = 0.0;
+        // estimate the object location by expected values
+        //@APPROX LABEL("WEIGHT_SUM") IN(arrayX[0:Nparticles], weights[0:Nparticles]) OUT(xe,ye) APPROX_TECH(MEMO_IN|MEMO_OUT|PERFO) 
+		#pragma omp parallel for private(x) reduction(+:xe, ye)
+        for(x = 0; x < Nparticles; x++){
+            xe += arrayX[x] * weights[x];
+            ye += arrayY[x] * weights[x];
+        }
+
+        positions[count]   = xe;
+        positions[count+1] = ye;
+        count+=2;
+
+        double distance = sqrt( pow((double)(xe-(int)round(IszY/2.0)),2) + pow((double)(ye-(int)round(IszX/2.0)),2) );
+
+        CDF[0] = weights[0];
+        for(x = 1; x < Nparticles; x++){
+            CDF[x] = weights[x] + CDF[x-1];
+        }
+
+        double randVal = randu(seed, 0);
+
+        double u1 = (1.0/((double)(Nparticles)))*randVal;
+		#pragma omp parallel for shared(u, u1, Nparticles) private(x)
+        for(x = 0; x < Nparticles; x++){
+            u[x] = u1 + x/((double)(Nparticles));
+        }
+        int j, i;
+
+//@APPROX LABEL("findIndex") IN(u[0:Nparticles],CDF[0:Nparticles], CDF[0:Nparticles]) OUT(xj[0:Nparticles],yj[0:Nparticles]) APPROX_TECH(MEMO_IN|MEMO_OUT|PERFO) 
+		#pragma omp parallel for shared(CDF, Nparticles, xj, yj, u, arrayX, arrayY) private(i, j)
+        for(j = 0; j < Nparticles; j++){
+            i = findIndex(CDF, Nparticles, u[j]);
+            if(i == -1)
+                i = Nparticles-1;
+            xj[j] = arrayX[i];
+            yj[j] = arrayY[i];
+
+        }
+
+        for(x = 0; x < Nparticles; x++){
+            //reassign arrayX and arrayY
+            arrayX[x] = xj[x];
+            arrayY[x] = yj[x];
+            weights[x] = 1.0/((double)(Nparticles));
+        }
+    }
+    free(disk);
+    free(objxy);
+    free(weights);
+    free(likelihood);
+    free(xj);
+    free(yj);
+    free(arrayX);
+    free(arrayY);
+    free(CDF);
+    free(u);
+    free(ind);
+    return positions;
+}
+
+
+int main(int argc, char * argv[]){
+    const char* usage = "openmp.out -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles -out outputfile>";
+    if(argc != 11)
+    {
+        printf("%s\n", usage);
+        return 0;
+    }
+    if( strcmp( argv[1], "-x" ) ||  strcmp( argv[3], "-y" ) || strcmp( argv[5], "-z" ) || strcmp( argv[7], "-np" ) || strcmp(argv[9],"-out")) {
+        printf( "%s\n",usage );
+        return 0;
+    }
+
+    int IszX, IszY, Nfr, Nparticles;
+    char *outputFile;
+
+    outputFile = argv[10];
+
+    if( sscanf( argv[2], "%d", &IszX ) == EOF ) {
+        printf("ERROR: dimX input is incorrect");
+        return 0;
+    }
+
+    if( IszX <= 0 ) {
+        printf("dimX must be > 0\n");
+        return 0;
+    }
+
+    if( sscanf( argv[4], "%d", &IszY ) == EOF ) {
+        printf("ERROR: dimY input is incorrect");
+        return 0;
+    }
+
+    if( IszY <= 0 ) {
+        printf("dimY must be > 0\n");
+        return 0;
+    }
+
+    if( sscanf( argv[6], "%d", &Nfr ) == EOF ) {
+        printf("ERROR: Number of frames input is incorrect");
+        return 0;
+    }
+
+    if( Nfr <= 0 ) {
+        printf("number of frames must be > 0\n");
+        return 0;
+    }
+
+    if( sscanf( argv[8], "%d", &Nparticles ) == EOF ) {
+        printf("ERROR: Number of particles input is incorrect");
+        return 0;
+    }
+
+    if( Nparticles <= 0 ) {
+        printf("Number of particles must be > 0\n");
+        return 0;
+    }
+    //establish seed
+    int * seed = (int *)malloc(sizeof(int)*Nparticles);
+    int i;
+    srand(3);
+    for(i = 0; i < Nparticles; i++)
+        seed[i] = rand();
+    //malloc matrix
+    int * I = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);
+    //call video sequence
+    videoSequence(I, IszX, IszY, Nfr, seed);
+    startMeasure();
+    //call particle filter
+    double *positions=particleFilter(I, IszX, IszY, Nfr, seed, Nparticles);
+    stopMeasure();
+    size_t sizeOfOutput=2*Nfr; 
+    writeData(positions,sizeOfOutput, DOUBLE, outputFile);
+
+    free(positions);
+    free(seed);
+    free(I);
+    return 0;
+}
diff -Naur ../original_src/rodinia_3.1/openmp/particlefilter/run particlefilter/run
--- ../original_src/rodinia_3.1/openmp/particlefilter/run	2021-07-27 19:40:03.134214000 -0700
+++ particlefilter/run	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-./particle_filter -x 128 -y 128 -z 10 -np 10000
